package things

// generated by pgtalk-gen on 2021-07-02 16:00:43.099882 &#43;0200 CEST m=&#43;0.025269574 DO NOT EDIT

import (
	"github.com/emicklei/pgtalk"
	"github.com/jackc/pgtype"
)

var (
	_         = pgtype.Date{}
	tableInfo = pgtalk.TableInfo{Name: "things", Alias: "t1"}
)

type Thing struct {
	TDate      *pgtype.Date
	TTimestamp *pgtype.Date
}

var (
	TDate      = pgtalk.NewDateAccess(tableInfo, "tDate", func(dest interface{}, v *pgtype.Date) { dest.(*Thing).TDate = v })
	TTimestamp = pgtalk.NewTimestampAccess(tableInfo, "tTimestamp", func(dest interface{}, v interface{}) { dest.(*Thing).TTimestamp = v })
)

func AllColumns() (all []pgtalk.ColumnAccessor) {
	return append(all, TDate, TTimestamp)
}

func Select(cas ...pgtalk.ColumnAccessor) ThingsQuerySet {
	return ThingsQuerySet{pgtalk.MakeQuerySet(tableInfo, cas, func() interface{} {
		return new(Thing)
	})}
}

type ThingsQuerySet struct {
	pgtalk.QuerySet
}

func (s ThingsQuerySet) Unwrap() pgtalk.QuerySet { return s.QuerySet }

// Where is
func (s ThingsQuerySet) Where(condition pgtalk.SQLWriter) ThingsQuerySet {
	return ThingsQuerySet{QuerySet: s.QuerySet.Where(condition)}
}

// Limit is
func (s ThingsQuerySet) Limit(limit int) ThingsQuerySet {
	return ThingsQuerySet{QuerySet: s.QuerySet.Limit(limit)}
}

// GroupBy is
func (s ThingsQuerySet) GroupBy(cas ...pgtalk.ColumnAccessor) ThingsQuerySet {
	return ThingsQuerySet{QuerySet: s.QuerySet.GroupBy(cas...)}
}

// GroupBy is
func (s ThingsQuerySet) OrderBy(cas ...pgtalk.ColumnAccessor) ThingsQuerySet {
	return ThingsQuerySet{QuerySet: s.QuerySet.OrderBy(cas...)}
}

// Exec is
func (s ThingsQuerySet) Exec(conn pgtalk.Connection) (list []*Thing, err error) {
	err = s.QuerySet.ExecWithAppender(conn, func(each interface{}) {
		list = append(list, each.(*Thing))
	})
	return
}

func Insert(cas ...pgtalk.ColumnAccessor) pgtalk.MutationSet {
	return pgtalk.MakeMutationSet(tableInfo, cas, pgtalk.MutationInsert)
}

func Delete() pgtalk.MutationSet {
	return pgtalk.MakeMutationSet(tableInfo, pgtalk.EmptyColumnAccessor, pgtalk.MutationDelete)
}

func Update(cas ...pgtalk.ColumnAccessor) pgtalk.MutationSet {
	return pgtalk.MakeMutationSet(tableInfo, cas, pgtalk.MutationUpdate)
}
