package categories
// generated by pgtalk-gen on 2021-07-13 17:12:48.022721 &#43;0200 CEST m=&#43;0.025501980 
// DO NOT EDIT

import (
	"github.com/emicklei/pgtalk"
	"time"
	"fmt"
	"bytes"
)

var (
	_ = time.Now()
	tableInfo = pgtalk.TableInfo{Schema: "public", Name: "categories", Alias: "c1"}
)

type Category struct {
	ID	*int64 // bigint
	Title	*string // text
}

var (	
	ID = pgtalk.NewInt64Access(tableInfo, "id", func(dest interface{}, v *int64) { dest.(*Category).ID = v })	
	Title = pgtalk.NewTextAccess(tableInfo, "title", func(dest interface{}, v *string) { dest.(*Category).Title = v })
)

func (e *Category) String() string {
	b := new(bytes.Buffer)
	fmt.Fprint(b, "categories.Category{")
	if e.ID != nil {
		fmt.Fprintf(b, "ID:%v ", *e.ID)
	}
	if e.Title != nil {
		fmt.Fprintf(b, "Title:%v ", *e.Title)
	}
	fmt.Fprint(b, "}")
	return b.String()
}

func AllColumns() (all []pgtalk.ColumnAccessor) {
	return append(all,ID,Title)
}

func Select(cas ...pgtalk.ColumnAccessor) CategorysQuerySet {
	return CategorysQuerySet{pgtalk.MakeQuerySet(tableInfo, cas, func() interface{} {
		return new(Category)
	})}
}

type CategorysQuerySet struct {
	pgtalk.QuerySet
}

func (s CategorysQuerySet) Unwrap() pgtalk.QuerySet { return s.QuerySet }

// Where is
func (s CategorysQuerySet) Where(condition pgtalk.SQLWriter) CategorysQuerySet {
	return CategorysQuerySet{QuerySet: s.QuerySet.Where(condition)}
}

// Limit is
func (s CategorysQuerySet) Limit(limit int) CategorysQuerySet {
	return CategorysQuerySet{QuerySet: s.QuerySet.Limit(limit)}
}

// GroupBy is
func (s CategorysQuerySet) GroupBy(cas ...pgtalk.ColumnAccessor) CategorysQuerySet {
	return CategorysQuerySet{QuerySet: s.QuerySet.GroupBy(cas...)}
}

// GroupBy is
func (s CategorysQuerySet) OrderBy(cas ...pgtalk.ColumnAccessor) CategorysQuerySet {
	return CategorysQuerySet{QuerySet: s.QuerySet.OrderBy(cas...)}
}

// Exec is
func (s CategorysQuerySet) Exec(conn pgtalk.Connection) (list []*Category, err error) {
	err = s.QuerySet.ExecWithAppender(conn, func(each interface{}) {
		list = append(list, each.(*Category))
	})
	return
}

func Insert(cas ...pgtalk.ColumnAccessor) pgtalk.MutationSet {
	return pgtalk.MakeMutationSet(tableInfo, cas, pgtalk.MutationInsert)
}

func Delete() pgtalk.MutationSet {
	return pgtalk.MakeMutationSet(tableInfo, pgtalk.EmptyColumnAccessor, pgtalk.MutationDelete)
}

func Update(cas ...pgtalk.ColumnAccessor) pgtalk.MutationSet {
	return pgtalk.MakeMutationSet(tableInfo, cas, pgtalk.MutationUpdate)
}
