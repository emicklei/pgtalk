package products

// generated by pgtalk-gen on 2021-09-09 16:46:12.085824 &#43;0200 CEST m=&#43;0.088223671
// DO NOT EDIT

import (
	"bytes"
	"fmt"
	"github.com/emicklei/pgtalk"
	"time"
)

var (
	_         = time.Now()
	tableInfo = pgtalk.TableInfo{Schema: "public", Name: "products", Alias: "p1"}
)

type Product struct {
	ID         *int64     // bigint
	CreatedAt  *time.Time // timestamp with time zone
	UpdatedAt  *time.Time // timestamp with time zone
	DeletedAt  *time.Time // timestamp with time zone
	Code       *string    // text
	Price      *int64     // bigint
	CategoryId *int64     // bigint
}

var (
	ID = pgtalk.NewInt64Access(pgtalk.MakeColumnInfo(tableInfo, "id", true, true, 1),
		func(dest interface{}, v *int64) { dest.(*Product).ID = v })
	CreatedAt = pgtalk.NewTimeAccess(pgtalk.MakeColumnInfo(tableInfo, "created_at", false, false, 2),
		func(dest interface{}, v *time.Time) { dest.(*Product).CreatedAt = v })
	UpdatedAt = pgtalk.NewTimeAccess(pgtalk.MakeColumnInfo(tableInfo, "updated_at", false, false, 3),
		func(dest interface{}, v *time.Time) { dest.(*Product).UpdatedAt = v })
	DeletedAt = pgtalk.NewTimeAccess(pgtalk.MakeColumnInfo(tableInfo, "deleted_at", false, false, 4),
		func(dest interface{}, v *time.Time) { dest.(*Product).DeletedAt = v })
	Code = pgtalk.NewTextAccess(pgtalk.MakeColumnInfo(tableInfo, "code", false, false, 5),
		func(dest interface{}, v *string) { dest.(*Product).Code = v })
	Price = pgtalk.NewInt64Access(pgtalk.MakeColumnInfo(tableInfo, "price", false, false, 6),
		func(dest interface{}, v *int64) { dest.(*Product).Price = v })
	CategoryId = pgtalk.NewInt64Access(pgtalk.MakeColumnInfo(tableInfo, "category_id", false, false, 7),
		func(dest interface{}, v *int64) { dest.(*Product).CategoryId = v })
	tableAccess = pgtalk.TableAccessor{TableInfo: tableInfo,
		Factory: func() interface{} { return new(Product) }, AllColumns: []pgtalk.ColumnAccessor{ID, CreatedAt, UpdatedAt, DeletedAt, Code, Price, CategoryId}}
)

// ColumnUpdatesFrom returns the list of changes to a Product for which updates need to be processed.
// Cannot be used to set null values for columns.
func ColumnUpdatesFrom(e *Product) (list []pgtalk.SQLExpression) {
	if e.ID != nil {
		list = append(list, ID.Set(*e.ID))
	}
	if e.CreatedAt != nil {
		list = append(list, CreatedAt.Set(*e.CreatedAt))
	}
	if e.UpdatedAt != nil {
		list = append(list, UpdatedAt.Set(*e.UpdatedAt))
	}
	if e.DeletedAt != nil {
		list = append(list, DeletedAt.Set(*e.DeletedAt))
	}
	if e.Code != nil {
		list = append(list, Code.Set(*e.Code))
	}
	if e.Price != nil {
		list = append(list, Price.Set(*e.Price))
	}
	if e.CategoryId != nil {
		list = append(list, CategoryId.Set(*e.CategoryId))
	}
	return
}

// String returns the debug string for *Product with all non-nil field values.
func (e *Product) String() string {
	b := new(bytes.Buffer)
	fmt.Fprint(b, "products.Product{")
	if e.ID != nil {
		fmt.Fprintf(b, "ID:%v ", *e.ID)
	}
	if e.CreatedAt != nil {
		fmt.Fprintf(b, "CreatedAt:%v ", *e.CreatedAt)
	}
	if e.UpdatedAt != nil {
		fmt.Fprintf(b, "UpdatedAt:%v ", *e.UpdatedAt)
	}
	if e.DeletedAt != nil {
		fmt.Fprintf(b, "DeletedAt:%v ", *e.DeletedAt)
	}
	if e.Code != nil {
		fmt.Fprintf(b, "Code:%v ", *e.Code)
	}
	if e.Price != nil {
		fmt.Fprintf(b, "Price:%v ", *e.Price)
	}
	if e.CategoryId != nil {
		fmt.Fprintf(b, "CategoryId:%v ", *e.CategoryId)
	}
	fmt.Fprint(b, "}")
	return b.String()
}

// AllColumns returns the list of all column accessors for usage in e.g. Select.
func AllColumns() []pgtalk.ColumnAccessor {
	return tableAccess.AllColumns
}

// Select returns a new QuerySet[Product] for fetching column data.
func Select(cas ...pgtalk.ColumnAccessor) pgtalk.QuerySet[Product] {
	return pgtalk.MakeQuerySet[Product](tableAccess, cas)
}

// Insert creates a MutationSet for inserting data with zero or more columns.
func Insert(cas ...pgtalk.ColumnAccessor) pgtalk.MutationSet[Product] {
	return pgtalk.MakeMutationSet[Product](tableAccess, cas, pgtalk.MutationInsert)
}

// Delete creates a MutationSet for deleting data.
func Delete() pgtalk.MutationSet[Product] {
	return pgtalk.MakeMutationSet[Product](tableAccess, pgtalk.EmptyColumnAccessor, pgtalk.MutationDelete)
}

// Update creates a MutationSet to update zero or more columns.
func Update(cas ...pgtalk.ColumnAccessor) pgtalk.MutationSet[Product] {
	return pgtalk.MakeMutationSet[Product](tableAccess, cas, pgtalk.MutationUpdate)
}
