package new_types
// generated by github.com/emicklei/pgtalk/cmd/pgtalk-gen from version: (devel)
// DO NOT EDIT

import (
	p "github.com/emicklei/pgtalk"
	c "github.com/emicklei/pgtalk/convert"
	"time"
	"strings"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

// NewType is generated from the public.new_types table.
type NewType struct {
	AChar	pgtype.Text // a_char : character
	AReal	pgtype.Float4 // a_real : real
	ASmallint	pgtype.Int2 // a_smallint : smallint
	ATime	pgtype.Time // a_time : time without time zone
	ID	int32 // id : integer
	// for storing custom field expression result values
	expressionResults map[string]any
}

var (
	// AChar represents the column "a_char" of with type "character", nullable:true, primary:false
	AChar = p.NewFieldAccess[pgtype.Text](p.MakeColumnInfo(tableInfo, "a_char", p.NotPrimary, p.Nullable, 0),
		func(dest any) any { return &dest.(*NewType).AChar })
	// AReal represents the column "a_real" of with type "real", nullable:true, primary:false
	AReal = p.NewFieldAccess[pgtype.Float4](p.MakeColumnInfo(tableInfo, "a_real", p.NotPrimary, p.Nullable, 0),
		func(dest any) any { return &dest.(*NewType).AReal })
	// ASmallint represents the column "a_smallint" of with type "smallint", nullable:true, primary:false
	ASmallint = p.NewFieldAccess[pgtype.Int2](p.MakeColumnInfo(tableInfo, "a_smallint", p.NotPrimary, p.Nullable, 0),
		func(dest any) any { return &dest.(*NewType).ASmallint })
	// ATime represents the column "a_time" of with type "time without time zone", nullable:true, primary:false
	ATime = p.NewFieldAccess[pgtype.Time](p.MakeColumnInfo(tableInfo, "a_time", p.NotPrimary, p.Nullable, 0),
		func(dest any) any { return &dest.(*NewType).ATime })
	// ID represents the column "id" of with type "integer", nullable:false, primary:true
	ID = p.NewInt32Access(p.MakeColumnInfo(tableInfo, "id", p.IsPrimary, p.NotNull, 0),
		func(dest any) any { return &dest.(*NewType).ID })
	// package private
	_ = c.UUID // for the occasional unused import from convert
	_ = time.Now
	_ = pgtype.Empty // for the occasional unused import from pgtype
	_ = decimal.Decimal{}
	tableInfo = p.TableInfo{Schema: "public", Name: "new_types", Alias: "nt1" }
)

func init() {
	// after var initialization (to prevent cycle) we need to update the tableInfo to set all columns
	tableInfo.Columns = []p.ColumnAccessor{AChar,AReal,ASmallint,ATime,ID, }
}

// TableInfo returns meta information about the table.
func TableInfo() p.TableInfo {
	return tableInfo
}


// SetAChar sets the value to the field value and returns the receiver.
func (e *NewType) SetAChar(v string) *NewType { e.AChar = c.StringToText(v) ; return e }


// SetAReal sets the value to the field value and returns the receiver.
func (e *NewType) SetAReal(v pgtype.Float4) *NewType { e.AReal = v ; return e }


// SetASmallint sets the value to the field value and returns the receiver.
func (e *NewType) SetASmallint(v int16) *NewType { e.ASmallint = c.Int16ToInt2(v) ; return e }


// SetATime sets the value to the field value and returns the receiver.
func (e *NewType) SetATime(v time.Time) *NewType { e.ATime = c.TimeToTime(v) ; return e }

// SetID sets the value to the field value and returns the receiver.
func (e *NewType) SetID(v int32) *NewType { e.ID = v ; return e }

// Setters returns the list of changes to a NewType for which updates/inserts need to be processed.
// Can be used in Insert,Update,Select. Cannot be used to set null (or empty array) values for columns.
func (e *NewType) Setters() (list []p.ColumnAccessor) {
	if e.AChar.Valid {
		list = append(list, AChar.Set(e.AChar))
	}
	if e.AReal.Valid {
		list = append(list, AReal.Set(e.AReal))
	}
	if e.ASmallint.Valid {
		list = append(list, ASmallint.Set(e.ASmallint))
	}
	if e.ATime.Valid {
		list = append(list, ATime.Set(e.ATime))
	}
	list = append(list, ID.Set(e.ID))
	return
}

// String returns the debug string for *NewType with all non-nil field values.
func (e *NewType) String() string {
	return p.StringWithFields(e, p.HideNilValues)
}

// Columns returns the ColumnAccessor list for the given column names.
// If the names is empty then return all columns.
func Columns(names ...string) (list []p.ColumnAccessor) {
	if len(names) == 0 {
		return tableInfo.Columns
	}
	for _, each := range names {
		for _, other := range tableInfo.Columns {
			n := other.Column().Name()
			if strings.HasPrefix(n,"'") { // mixed case names are quoted
				n = strings.Trim(n,"'")
			}
			if n == each {
				list = append(list, other)
			}
		}
	}
	return
}

// AddExpressionResult puts a value into the custom expression results
func (e *NewType) AddExpressionResult(key string, value any) {
	if e.expressionResults == nil {
		// lazy initialize
		e.expressionResults = map[string]any{}
	}
	e.expressionResults[key]=value
}

// GetExpressionResult gets a value from the custom expression results. Returns nil if absent.
func (e *NewType) GetExpressionResult(key string) any {
	v, ok := e.expressionResults[key]
	if !ok {
		return nil
	}
	pv := v.(*any)
	return *pv
}

// Select returns a new QuerySet[NewType] for fetching column data.
func Select(cas ...p.ColumnAccessor) p.QuerySet[NewType] {
	return p.MakeQuerySet[NewType](tableInfo, cas)
}

// Insert creates a MutationSet for inserting data with zero or more columns.
func Insert(cas ...p.ColumnAccessor) p.MutationSet[NewType] {
	return p.MakeMutationSet[NewType](tableInfo, cas, p.MutationInsert)
}

// Delete creates a MutationSet for deleting data.
func Delete() p.MutationSet[NewType] {
	return p.MakeMutationSet[NewType](tableInfo, p.EmptyColumnAccessor, p.MutationDelete)
}

// Update creates a MutationSet to update zero or more columns.
func Update(cas ...p.ColumnAccessor) p.MutationSet[NewType] {
	return p.MakeMutationSet[NewType](tableInfo, cas, p.MutationUpdate)
}
